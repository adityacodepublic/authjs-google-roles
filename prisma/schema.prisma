generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Auth
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  role          String?   @default("null")
  accounts      Account[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

// Order
model Order {
  id           String       @id
  description  String
  org          String
  organisation organisation @relation("OrgToOrder", fields: [org], references: [id])
  printing     String       @db.VarChar(20)
  filmSize     String       @db.VarChar(20)
  flimSizes    FilmSize     @relation(fields: [filmSize], references: [id])
  canSize      String       @db.VarChar(20)
  canSizes     CanSize      @relation(fields: [canSize], references: [id])
  type         String       @db.VarChar(30)
  wireType     String       @db.VarChar(20)
  wireTypes    WireType     @relation(fields: [wireType], references: [id])
  wireLength   String       @db.VarChar(20)
  quantity     Int
  complete     Boolean      @default(false)
  batches      Batch[]      @relation("OrderToBatch")
  user         String // get details from cache util 
  createdAt    DateTime     @default(now())
  completedAt  DateTime?

  @@index([org])
}

model FilmSize {
  id     String  @id
  name   String
  orders Order[]
}

model CanSize {
  id     String  @id
  name   String
  orders Order[]
}

model WireType {
  id     String  @id
  name   String
  orders Order[]
}

model organisation {
  id     String  @id @default(cuid())
  name   String
  orders Order[] @relation("OrgToOrder")
}

model Process {
  id      String  @id @default(uuid())
  name    String
  batches Batch[] @relation("ProcessToBatch")
}

model Batch {
  id        String         @id @default(uuid())
  orderId   String
  order     Order          @relation("OrderToBatch", fields: [orderId], references: [id], onDelete: Cascade)
  batch     String
  processId String
  process   Process        @relation("ProcessToBatch", fields: [processId], references: [id])
  completed Boolean        @default(false)
  logs      Log[]          @relation("BatchToProcess")
  stockLogs OutStockLogs[] @relation("BatchToOutStockLogs")

  @@index([processId])
  @@index([orderId])
}

model Log {
  id      String @id @default(cuid())
  batchId String
  batch   Batch  @relation("BatchToProcess", fields: [batchId], references: [id])
  user    String // Will get details from the cache util 

  quantity Int @default(0)

  start DateTime @default(now())
  pause DateTime @updatedAt

  @@index([batchId])
}

model ExcessStock {
  id        String   @id @default(cuid())
  batchId   String
  quantity  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Inventory
// Product === Raw Material
model Supplier {
  id       String    @id @default(cuid())
  name     String
  contacts String[] // contacts: name-contact, email - util
  address  String
  products InStock[]
}

model ProductCategory {
  id       String    @id @default(cuid())
  name     String
  products Product[] @relation("ProductCategoryToProduct")
}

model Product {
  code              String          @id
  name              String
  productCategoryId String
  productCategory   ProductCategory @relation("ProductCategoryToProduct", fields: [productCategoryId], references: [id])
  valueUnit         String          @db.VarChar(15)
  quantity          Int
  inQuantity        ProductIn[]
  outQuantity       OutStockLogs[]  @relation("ProductToOutStockLogs")
  updatedAt         DateTime        @updatedAt

  @@index([productCategoryId])
}

model InStock {
  id           String      @id @default(cuid())
  user         String // get details through cache util util
  supplierId   String
  supplier     Supplier    @relation(fields: [supplierId], references: [id])
  products     ProductIn[]
  totalPrice   Float
  payment      Boolean     @default(true)
  paymentDays  Int         @default(0)
  delivery     Boolean     @default(true)
  deliveryDays Int         @default(0)
  updated      Boolean     @default(false)
  confirmed    Boolean     @default(true) // false for po 
  po           Boolean     @default(false)
  poData       String?
  updatedAt    DateTime    @updatedAt

  // pending in days as difference between pendingDays and updatedAt
  @@index([supplierId])
}

model ProductIn {
  id          String  @id @default(cuid())
  instockId   String
  inStock     InStock @relation(fields: [instockId], references: [id], onDelete: Cascade)
  productId   String
  index       String  @db.VarChar(3)
  product     Product @relation(fields: [productId], references: [code])
  description String
  quantity    Int
  unitRate    Float
  boxes       String  @default("")
  amount      Float

  @@index([productId])
  @@index([instockId])
}

model OutStockLogs {
  id        String   @id @default(cuid())
  productId String
  products  Product  @relation("ProductToOutStockLogs", fields: [productId], references: [code])
  userId    String
  batchId   String
  batch     Batch    @relation("BatchToOutStockLogs", fields: [batchId], references: [id])
  quantity  Int
  updatedAt DateTime @updatedAt

  @@index([productId])
  @@index([batchId])
}
